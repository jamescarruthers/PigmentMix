<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Golden Paint Mixer with Kubelka-Munk Theory</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/tailwindcss/2.2.19/tailwind.min.css" rel="stylesheet">
    <style>
        .paint-list {
            max-height: 400px;
            overflow-y: auto;
        }
        .paint-list-item {
            display: flex;
            align-items: center;
            padding: 8px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .paint-list-item:hover {
            background-color: #f0f0f0;
        }
        .paint-list-item.selected {
            background-color: #e6f2ff;
            font-weight: bold;
        }
        .paint-swatch {
            width: 30px;
            height: 30px;
            margin-right: 10px;
            border-radius: 50%;
            border: 1px solid #ddd;
        }
        .reflectance-chart {
            width: 100%;
            height: 300px;
            border: 1px solid #ddd;
            margin-top: 20px;
        }
        .concentration-slider {
            width: 100%;
            margin: 10px 0;
        }
        .result-swatch {
            display: block;
            width: 100px;
            height: 100px;
            border: 1px solid #ddd;
            margin: 10px 0;
        }
        .tab {
            cursor: pointer;
            padding: 10px 20px;
            margin-right: 4px;
            border-radius: 4px 4px 0 0;
            background-color: #f0f0f0;
            border: 1px solid #ddd;
            border-bottom: none;
        }
        .tab.active {
            background-color: #fff;
            border-bottom: 1px solid #fff;
            margin-bottom: -1px;
            font-weight: bold;
        }
        .tab-content {
            display: none;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 0 4px 4px 4px;
        }
        .tab-content.active {
            display: block;
        }
        .match-result {
            border: 1px solid #ddd;
            margin-bottom: 10px;
            padding: 10px;
            border-radius: 4px;
        }
    </style>
</head>

<body class="bg-gray-50">
    <div class="container mx-auto p-4 max-w-6xl">
        <h1 class="text-3xl font-bold text-center my-6">Golden Paint Mixer</h1>
        <p class="text-center mb-8">Using Kubelka-Munk Theory for accurate pigment mixing simulation</p>

        <div id="app" class="bg-white shadow-lg rounded-lg p-6">
            <div id="loading" class="text-center p-10">
                <p class="text-lg">Loading paint data and libraries...</p>
            </div>

            <div id="content" class="hidden">
                <!-- Tab navigation -->
                <div class="mb-6 border-b">
                    <div class="flex">
                        <div class="tab active" data-tab="mixer">Paint Mixer</div>
                        <div class="tab" data-tab="matcher">Color Matcher</div>
                    </div>
                </div>

                <!-- Paint Mixer Tab -->
                <div id="mixer-tab" class="tab-content active">
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
                        <!-- Paint selection panel -->
                        <div class="paint-selection">
                            <h2 class="text-xl font-semibold mb-4">Available Paints</h2>
                            <div class="mb-4">
                                <input type="text" id="paint-search" placeholder="Search paints..." 
                                       class="w-full p-2 border rounded">
                            </div>
                            <div id="paint-list" class="paint-list border rounded"></div>
                        </div>

                        <!-- Mixing controls and results -->
                        <div class="mixing-panel">
                            <h2 class="text-xl font-semibold mb-4">Paint Mixture</h2>
                            <div id="selected-paints" class="mb-6"></div>

                            <div id="result-area" class="hidden">
                                <h3 class="text-lg font-semibold">Mixed Result</h3>
                                <div class="flex items-center mt-2">
                                    <div id="result-swatch" class="result-swatch"></div>
                                    <div class="ml-4">
                                        <p>Hex: <span id="result-hex" class="font-mono"></span></p>
                                        <p>RGB: <span id="result-rgb" class="font-mono"></span></p>
                                    </div>
                                </div>

                                <h3 class="text-lg font-semibold mt-6">Reflectance Curve</h3>
                                <canvas id="reflectance-chart" width="500" height="300" class="reflectance-chart"></canvas>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Color Matcher Tab -->
                <div id="matcher-tab" class="tab-content">
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
                        <!-- Target color section -->
                        <div class="target-color">
                            <h2 class="text-xl font-semibold mb-4">Target Color</h2>
                            
                            <div class="mb-4 flex items-center">
                                <div class="flex-1">
                                    <label class="block text-sm mb-1">HEX Color:</label>
                                    <input type="text" id="target-hex" placeholder="#RRGGBB" 
                                       class="w-full p-2 border rounded" value="#3366CC">
                                </div>
                                <div class="ml-4">
                                    <input type="color" id="target-color-picker" value="#3366CC" 
                                       class="w-12 h-10 block mt-5">
                                </div>
                            </div>

                            <div class="mb-4">
                                <button id="toggle-input-type" class="px-3 py-1 bg-blue-600 text-white rounded text-sm">
                                    Switch to HSV
                                </button>
                            </div>

                            <!-- HSV controls (initially hidden) -->
                            <div id="hsv-controls" class="mb-4 hidden">
                                <div class="mb-2">
                                    <label class="block text-sm mb-1">Hue (0-359):</label>
                                    <input type="range" id="hsv-h" min="0" max="359" value="0" class="w-full">
                                    <div class="flex justify-between">
                                        <span class="text-xs">0</span>
                                        <span class="text-xs">359</span>
                                    </div>
                                </div>
                                <div class="mb-2">
                                    <label class="block text-sm mb-1">Saturation (0-100):</label>
                                    <input type="range" id="hsv-s" min="0" max="100" value="0" class="w-full">
                                    <div class="flex justify-between">
                                        <span class="text-xs">0%</span>
                                        <span class="text-xs">100%</span>
                                    </div>
                                </div>
                                <div class="mb-2">
                                    <label class="block text-sm mb-1">Value (0-100):</label>
                                    <input type="range" id="hsv-v" min="0" max="100" value="0" class="w-full">
                                    <div class="flex justify-between">
                                        <span class="text-xs">0%</span>
                                        <span class="text-xs">100%</span>
                                    </div>
                                </div>
                            </div>
                            
                            <h3 class="font-medium mb-2 mt-6 border-t pt-4">Available Paints</h3>
                            <div class="mb-3 flex items-center justify-between">
                                <div class="text-sm">
                                    <span id="selected-paints-count">0</span> of <span id="total-paints-count">0</span> paints selected
                                </div>
                                <div>
                                    <button id="select-all-paints" class="px-2 py-1 bg-blue-100 text-blue-800 rounded text-xs mr-1">
                                        Select All
                                    </button>
                                    <button id="clear-all-paints" class="px-2 py-1 bg-gray-100 text-gray-800 rounded text-xs">
                                        Clear All
                                    </button>
                                </div>
                            </div>
                            
                            <div class="mb-2">
                                <input type="text" id="paint-filter" placeholder="Filter paints..." 
                                   class="w-full p-2 border rounded text-sm">
                            </div>
                            
                            <div id="available-paints-container" class="border rounded mb-4 h-40 overflow-y-auto p-1">
                                <!-- Paint selection checkboxes will be added here -->
                                <div class="text-center text-gray-500 py-12">Loading paints...</div>
                            </div>

                            <div class="mb-4">
                                <button id="find-matches" class="w-full p-2 bg-green-600 text-white rounded font-medium">
                                    Find Matching Paints
                                </button>
                            </div>

                            <div class="text-sm text-gray-600">
                                <p>This tool will find the best combination of selected Golden paints to match your desired color.</p>
                                <p class="mt-2">Note: Not all colors can be perfectly matched with physical pigments.</p>
                            </div>
                        </div>

                        <!-- Match results section -->
                        <div class="match-results">
                            <h2 class="text-xl font-semibold mb-4">Match Results</h2>
                            <div id="match-loading" class="hidden">
                                <p class="text-center py-10">Finding best paint matches...</p>
                            </div>
                            <div id="no-matches" class="hidden">
                                <p class="text-center py-10 text-gray-500">No matches found yet. Select a color and click "Find Matching Paints".</p>
                            </div>
                            <div id="matches-container"></div>
                        </div>
                    </div>
                </div>
                
                <div class="mt-10 pt-6 border-t">
                    <h2 class="text-xl font-semibold mb-2">About This Tool</h2>
                    <p class="mb-2">This paint mixer simulates the mixing of Golden Heavy Body Acrylics using the
                        Kubelka-Munk theory, which accurately models how pigments interact with light when mixed.</p>
                    <p class="mb-2">Unlike RGB color mixing (which simulates how light mixes), Kubelka-Munk theory
                        simulates how pigments mix, accounting for both light absorption and scattering properties. This
                        provides more realistic results that better match actual paint mixing behavior.</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Load our JavaScript libraries -->
    <script src="kubelkamunk.js"></script>

    <script>
        // Wait for the DOM to be fully loaded
        window.addEventListener('DOMContentLoaded', function () {
            // Check if the KubelkaMunk library is available
            const checkLibrariesLoaded = setInterval(function () {
                if (window.KubelkaMunk) {
                    clearInterval(checkLibrariesLoaded);
                    fetchPaintData();
                }
            }, 100);

            // Set a timeout in case the library doesn't load
            setTimeout(function () {
                clearInterval(checkLibrariesLoaded);
                if (!window.KubelkaMunk) {
                    alert('Error loading required libraries. Please refresh the page.');
                }
            }, 5000);

            // Fetch paint data from JSON
            async function fetchPaintData() {
                try {
                    const response = await fetch('golden_heavy_body.json');
                    const allPaints = await response.json();
                    
                    // Filter out paints with color and reflectance data
                    const paints = allPaints.filter(paint => 
                        paint.color && 
                        paint.color.reflectance_curve && 
                        !paint.discontinued
                    ).map(paint => ({
                        id: paint.id,
                        color_name: paint.color_name,
                        rgb_hex: paint.color.srgb.rgb_hex,
                        reflectance: paint.color.reflectance_curve,
                        series: paint.series || 'N/A',
                        transparency: paint.transparency || 'N/A',
                        pigments: paint.pigments?.ci_color_codes || []
                    })).sort((a, b) => a.color_name.localeCompare(b.color_name));

                    initializeApp(paints);
                } catch (error) {
                    console.error('Error loading paint data:', error);
                    alert('Failed to load paint data. Please refresh the page.');
                }
            }

            // Initialize the app with paint data
            function initializeApp(paints) {
                // Hide loading, show content
                document.getElementById('loading').classList.add('hidden');
                document.getElementById('content').classList.remove('hidden');

                // Initialize Kubelka-Munk
                const km = new KubelkaMunk();

                // Initialize tabs
                initializeTabs();

                // Initialize Paint Mixer
                initializePaintMixer(paints, km);

                // Initialize Color Matcher
                initializeColorMatcher(paints, km);
            }

            // Initialize tabbed interface
            function initializeTabs() {
                const tabs = document.querySelectorAll('.tab');
                const tabContents = document.querySelectorAll('.tab-content');

                tabs.forEach(tab => {
                    tab.addEventListener('click', function() {
                        // Remove active class from all tabs and contents
                        tabs.forEach(t => t.classList.remove('active'));
                        tabContents.forEach(c => c.classList.remove('active'));
                        
                        // Add active class to clicked tab and corresponding content
                        this.classList.add('active');
                        const tabId = this.getAttribute('data-tab');
                        document.getElementById(`${tabId}-tab`).classList.add('active');
                        
                        // Check if we're switching to the mixer tab and have paints to add
                        if (tabId === 'mixer' && localStorage.getItem('mixerPaints')) {
                            const paintsToAdd = JSON.parse(localStorage.getItem('mixerPaints'));
                            
                            // Clear localStorage to prevent re-adding on future tab switches
                            localStorage.removeItem('mixerPaints');
                            
                            // Add these paints to the mixer (we'll implement this in the paint mixer)
                            if (typeof addPaintsToMixer === 'function') {
                                addPaintsToMixer(paintsToAdd);
                            }
                        }
                    });
                });
            }

            // Initialize the paint mixer functionality
            function initializePaintMixer(paints, km) {
                // State for selected paints
                const selectedPaints = [];
                
                // Function to add paints from matcher to mixer
                window.addPaintsToMixer = function(paintsToAdd) {
                    // Add each paint to the mixer
                    paintsToAdd.forEach(paint => {
                        // Check if the paint is already selected
                        const existingIndex = selectedPaints.findIndex(p => p.id === paint.id);
                        
                        if (existingIndex === -1) {
                            // Add the paint with the specified concentration
                            selectedPaints.push({
                                id: paint.id,
                                color_name: paint.color_name,
                                rgb_hex: paint.rgb_hex,
                                reflectance: paint.reflectance,
                                concentration: paint.concentration
                            });
                            
                            // Update the paint list UI to show it as selected
                            const paintListItem = document.querySelector(`.paint-list-item[data-id="${paint.id}"]`);
                            if (paintListItem) {
                                paintListItem.classList.add('selected');
                            }
                        } else {
                            // Update the concentration if the paint is already selected
                            selectedPaints[existingIndex].concentration = paint.concentration;
                        }
                    });
                    
                    // Update the UI
                    updateSelectedPaintsUI();
                    updateMixedResult();
                };

                // Populate paint list
                const paintListContainer = document.getElementById('paint-list');
                const searchInput = document.getElementById('paint-search');

                function renderPaintList(filteredPaints) {
                    paintListContainer.innerHTML = '';
                    filteredPaints.forEach(function (paint) {
                        const paintItem = document.createElement('div');
                        paintItem.className = 'paint-list-item';
                        paintItem.setAttribute('data-id', paint.id);
                        
                        paintItem.innerHTML = `
                            <div class="paint-swatch" style="background-color: ${paint.rgb_hex}"></div>
                            <div class="flex-grow">
                                <div class="font-medium">${paint.color_name}</div>
                                <div class="text-xs text-gray-500">
                                    Series ${paint.series} (${paint.transparency}) 
                                    ${paint.pigments.length > 0 ? '• ' + paint.pigments.join(', ') : ''}
                                </div>
                            </div>
                        `;

                        // Check if this paint is already selected
                        if (selectedPaints.some(p => p.id === paint.id)) {
                            paintItem.classList.add('selected');
                        }

                        paintItem.addEventListener('click', function () {
                            togglePaintSelection(paint);
                        });

                        paintListContainer.appendChild(paintItem);
                    });
                }

                // Search functionality
                searchInput.addEventListener('input', function () {
                    const searchTerm = this.value.toLowerCase();
                    const filteredPaints = paints.filter(paint => 
                        paint.color_name.toLowerCase().includes(searchTerm)
                    );
                    renderPaintList(filteredPaints);
                });

                // Initial render of paint list
                renderPaintList(paints);

                // Toggle paint selection
                function togglePaintSelection(paint) {
                    const existingIndex = selectedPaints.findIndex(function (p) {
                        return p.id === paint.id;
                    });

                    const paintListItem = document.querySelector(`.paint-list-item[data-id="${paint.id}"]`);

                    if (existingIndex >= 0) {
                        // Remove the paint
                        selectedPaints.splice(existingIndex, 1);
                        paintListItem.classList.remove('selected');
                    } else {
                        // Add the paint with default concentration
                        selectedPaints.push({
                            id: paint.id,
                            color_name: paint.color_name,
                            rgb_hex: paint.rgb_hex,
                            reflectance: paint.reflectance,
                            concentration: 1
                        });
                        paintListItem.classList.add('selected');
                    }

                    // Update the UI
                    updateSelectedPaintsUI();
                    updateMixedResult();
                }

                // Update the selected paints section
                function updateSelectedPaintsUI() {
                    const container = document.getElementById('selected-paints');
                    container.innerHTML = '';

                    if (selectedPaints.length === 0) {
                        container.innerHTML = '<p class="text-gray-500">No paints selected. Click on paints to add them to your mixture.</p>';
                        return;
                    }

                    selectedPaints.forEach(function (paint, index) {
                        const paintElement = document.createElement('div');
                        paintElement.className = 'flex items-center mb-4 p-2 border rounded';
                        paintElement.innerHTML = `
                            <div style="background-color: ${paint.rgb_hex}" class="w-8 h-8 rounded-full mr-3"></div>
                            <div class="flex-1">
                                <div class="font-medium">${paint.color_name}</div>
                                <div class="text-xs text-gray-600">
                                    ${paint.pigments.length > 0 ? paint.pigments.join(', ') : ''}
                                </div>
                            </div>
                            <div class="w-32">
                                <label class="block text-sm">Concentration</label>
                                <input type="range" min="0.1" max="5" step="0.1" value="${paint.concentration}" 
                                    class="concentration-slider" data-index="${index}">
                                <div class="text-center text-sm">${paint.concentration}</div>
                            </div>
                            <button class="ml-2 text-red-500 p-2" data-index="${index}">✕</button>
                        `;

                        // Add event listeners
                        const slider = paintElement.querySelector('.concentration-slider');
                        slider.addEventListener('input', function (e) {
                            const value = parseFloat(e.target.value);
                            const index = parseInt(e.target.dataset.index);
                            selectedPaints[index].concentration = value;
                            e.target.nextElementSibling.textContent = value;
                            updateMixedResult();
                        });

                        const removeBtn = paintElement.querySelector('button');
                        removeBtn.addEventListener('click', function () {
                            const indexToRemove = parseInt(removeBtn.dataset.index);
                            const paintToRemove = selectedPaints[indexToRemove];
                            
                            // Remove from selectedPaints
                            selectedPaints.splice(indexToRemove, 1);
                            
                            // Unselect in paint list
                            const paintListItem = document.querySelector(`.paint-list-item[data-id="${paintToRemove.id}"]`);
                            if (paintListItem) {
                                paintListItem.classList.remove('selected');
                            }
                            
                            // Update UI
                            updateSelectedPaintsUI();
                            updateMixedResult();
                        });

                        container.appendChild(paintElement);
                    });
                }

                // Update the mixed result
                function updateMixedResult() {
                    const resultArea = document.getElementById('result-area');

                    if (selectedPaints.length === 0) {
                        resultArea.classList.add('hidden');
                        return;
                    }

                    resultArea.classList.remove('hidden');

                    // Prepare components for mixing
                    const components = selectedPaints.map(function (paint) {
                        return {
                            reflectance: paint.reflectance,
                            concentration: paint.concentration
                        };
                    });

                    // Mix the paints using Kubelka-Munk
                    const mixedReflectance = km.mixReflectance(components);

                    // Convert to RGB and hex
                    const rgb = km.reflectanceToRGB(mixedReflectance);
                    const hexColor = km.rgbToHex(rgb);

                    // Update the result UI
                    document.getElementById('result-swatch').style.backgroundColor = hexColor;
                    document.getElementById('result-hex').textContent = hexColor;
                    document.getElementById('result-rgb').textContent = `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})`;

                    // Draw the reflectance curve
                    drawReflectanceCurve(mixedReflectance);
                }

                // Draw the reflectance curve on a canvas
                function drawReflectanceCurve(reflectance) {
                    const canvas = document.getElementById('reflectance-chart');
                    const ctx = canvas.getContext('2d');
                    const width = canvas.width;
                    const height = canvas.height;

                    // Clear canvas
                    ctx.clearRect(0, 0, width, height);

                    // Draw background grid
                    ctx.beginPath();
                    ctx.strokeStyle = '#eee';
                    for (let i = 0; i <= 10; i++) {
                        const y = height - 30 - (i / 10) * (height - 40);
                        ctx.moveTo(30, y);
                        ctx.lineTo(width - 10, y);
                    }
                    for (let i = 0; i <= 30; i += 5) {
                        const x = 30 + (i / 30) * (width - 40);
                        ctx.moveTo(x, 10);
                        ctx.lineTo(x, height - 30);
                    }
                    ctx.stroke();

                    // Draw axes
                    ctx.beginPath();
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 1;
                    // Y-axis
                    ctx.moveTo(30, 10);
                    ctx.lineTo(30, height - 30);
                    // X-axis
                    ctx.moveTo(30, height - 30);
                    ctx.lineTo(width - 10, height - 30);
                    ctx.stroke();

                    // Add labels
                    ctx.fillStyle = '#000';
                    ctx.font = '10px Arial';

                    // X-axis labels (wavelengths)
                    for (let i = 0; i <= 30; i += 5) {
                        const wavelength = 400 + i * 10;
                        const x = 30 + (i / 30) * (width - 40);
                        ctx.fillText(wavelength, x - 10, height - 15);
                    }

                    // Y-axis labels (reflectance)
                    for (let i = 0; i <= 10; i += 2) {
                        const y = height - 30 - (i / 10) * (height - 40);
                        ctx.fillText((i / 10).toFixed(1), 10, y + 3);
                    }

                    // Title
                    ctx.font = '12px Arial';
                    ctx.fillText('Wavelength (nm)', width / 2 - 40, height - 5);
                    ctx.save();
                    ctx.translate(15, height / 2);
                    ctx.rotate(-Math.PI / 2);
                    ctx.fillText('Reflectance', 0, 0);
                    ctx.restore();

                    // Draw individual reflectance curves for selected paints
                    selectedPaints.forEach(function (paint) {
                        drawCurve(paint.reflectance, paint.rgb_hex, 1);
                    });

                    // Draw the mixed reflectance curve
                    drawCurve(reflectance, '#000000', 2);

                    // Helper function to draw a curve
                    function drawCurve(data, color, lineWidth) {
                        ctx.beginPath();
                        for (let i = 0; i < data.length; i++) {
                            const x = 30 + (i / (data.length - 1)) * (width - 40);
                            const y = height - 30 - (data[i] * (height - 40));

                            if (i === 0) {
                                ctx.moveTo(x, y);
                            } else {
                                ctx.lineTo(x, y);
                            }
                        }
                        ctx.strokeStyle = color;
                        ctx.lineWidth = lineWidth;
                        ctx.stroke();
                    }
                }
            }

            // Initialize the color matcher functionality
            function initializeColorMatcher(paints, km) {
                // DOM elements
                const targetHexInput = document.getElementById('target-hex');
                const targetColorPicker = document.getElementById('target-color-picker');
                const toggleInputTypeBtn = document.getElementById('toggle-input-type');
                const hsvControls = document.getElementById('hsv-controls');
                const hsvHInput = document.getElementById('hsv-h');
                const hsvSInput = document.getElementById('hsv-s');
                const hsvVInput = document.getElementById('hsv-v');
                const findMatchesBtn = document.getElementById('find-matches');
                const matchesContainer = document.getElementById('matches-container');
                const matchLoading = document.getElementById('match-loading');
                const noMatches = document.getElementById('no-matches');
                const paintFilterInput = document.getElementById('paint-filter');
                const availablePaintsContainer = document.getElementById('available-paints-container');
                const selectAllPaintsBtn = document.getElementById('select-all-paints');
                const clearAllPaintsBtn = document.getElementById('clear-all-paints');
                const selectedPaintsCountEl = document.getElementById('selected-paints-count');
                const totalPaintsCountEl = document.getElementById('total-paints-count');

                // Initial state
                let inputMode = 'rgb';
                let targetHsv = { h: 0, s: 0, v: 0 };
                let availablePaints = [...paints]; // Copy the paints array
                let selectedPaintIds = paints.map(p => p.id); // Initially all paints are selected
                updateHsvFromHex('#3366CC');

                // Show no matches initially
                noMatches.classList.remove('hidden');
                
                // Update paint counts
                totalPaintsCountEl.textContent = paints.length;
                selectedPaintsCountEl.textContent = selectedPaintIds.length;

                // Event listeners
                targetHexInput.addEventListener('input', function(e) {
                    const value = e.target.value;
                    if (value.match(/^#[0-9A-Fa-f]{6}$/)) {
                        targetColorPicker.value = value;
                        if (inputMode === 'rgb') {
                            updateHsvFromHex(value);
                        }
                    }
                });

                targetColorPicker.addEventListener('input', function(e) {
                    const value = e.target.value;
                    targetHexInput.value = value;
                    if (inputMode === 'rgb') {
                        updateHsvFromHex(value);
                    }
                });

                toggleInputTypeBtn.addEventListener('click', function() {
                    if (inputMode === 'rgb') {
                        inputMode = 'hsv';
                        this.textContent = 'Switch to RGB';
                        hsvControls.classList.remove('hidden');
                        // Ensure HSV is up to date
                        updateHsvFromHex(targetHexInput.value);
                    } else {
                        inputMode = 'rgb';
                        this.textContent = 'Switch to HSV';
                        hsvControls.classList.add('hidden');
                    }
                });

                hsvHInput.addEventListener('input', updateHexFromHsv);
                hsvSInput.addEventListener('input', updateHexFromHsv);
                hsvVInput.addEventListener('input', updateHexFromHsv);

                findMatchesBtn.addEventListener('click', findMatches);

                // Convert RGB to HSV
                function hexToHsv(hex) {
                    // Remove # if present
                    hex = hex.replace('#', '');
                    
                    // Convert hex to RGB
                    const r = parseInt(hex.substring(0, 2), 16) / 255;
                    const g = parseInt(hex.substring(2, 4), 16) / 255;
                    const b = parseInt(hex.substring(4, 6), 16) / 255;
                    
                    const max = Math.max(r, g, b);
                    const min = Math.min(r, g, b);
                    const diff = max - min;
                    
                    let h = 0;
                    if (max === min) {
                        h = 0;
                    } else if (max === r) {
                        h = (60 * ((g - b) / diff) + 360) % 360;
                    } else if (max === g) {
                        h = (60 * ((b - r) / diff) + 120) % 360;
                    } else if (max === b) {
                        h = (60 * ((r - g) / diff) + 240) % 360;
                    }
                    
                    const s = max === 0 ? 0 : diff / max;
                    const v = max;
                    
                    return { 
                        h: Math.round(h), 
                        s: Math.round(s * 100), 
                        v: Math.round(v * 100) 
                    };
                }

                // Convert HSV to RGB
                function hsvToHex(h, s, v) {
                    h = h % 360;
                    s = s / 100;
                    v = v / 100;
                    
                    const c = v * s;
                    const x = c * (1 - Math.abs(((h / 60) % 2) - 1));
                    const m = v - c;
                    
                    let r, g, b;
                    if (h >= 0 && h < 60) {
                        [r, g, b] = [c, x, 0];
                    } else if (h >= 60 && h < 120) {
                        [r, g, b] = [x, c, 0];
                    } else if (h >= 120 && h < 180) {
                        [r, g, b] = [0, c, x];
                    } else if (h >= 180 && h < 240) {
                        [r, g, b] = [0, x, c];
                    } else if (h >= 240 && h < 300) {
                        [r, g, b] = [x, 0, c];
                    } else {
                        [r, g, b] = [c, 0, x];
                    }
                    
                    r = Math.round((r + m) * 255);
                    g = Math.round((g + m) * 255);
                    b = Math.round((b + m) * 255);
                    
                    // Convert to hex
                    return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
                }

                // Update HSV inputs from hex color
                function updateHsvFromHex(hex) {
                    targetHsv = hexToHsv(hex);
                    hsvHInput.value = targetHsv.h;
                    hsvSInput.value = targetHsv.s;
                    hsvVInput.value = targetHsv.v;
                }

                // Update hex input from HSV sliders
                function updateHexFromHsv() {
                    targetHsv = {
                        h: parseInt(hsvHInput.value),
                        s: parseInt(hsvSInput.value),
                        v: parseInt(hsvVInput.value)
                    };
                    
                    const hex = hsvToHex(targetHsv.h, targetHsv.s, targetHsv.v);
                    targetHexInput.value = hex;
                    targetColorPicker.value = hex;
                }

                // Approximate reflectance curve from RGB (simplistic approach)
                function rgbToReflectance(hexColor) {
                    // Remove # if present
                    hexColor = hexColor.replace('#', '');
                    
                    // Convert hex to RGB
                    const r = parseInt(hexColor.substring(0, 2), 16) / 255;
                    const g = parseInt(hexColor.substring(2, 4), 16) / 255;
                    const b = parseInt(hexColor.substring(4, 6), 16) / 255;
                    
                    // Generate a simple approximation (this would be more sophisticated in a real implementation)
                    return Array(31).fill(0).map((_, i) => {
                        const wavelength = 400 + i * 10;
                        
                        // Approximate sensitivity of RGB to wavelengths
                        let reflectance = 0;
                        
                        // Red sensitivity peaks at longer wavelengths
                        if (wavelength >= 580) {
                            reflectance += r * Math.min(1, (wavelength - 580) / 120 + 0.5);
                        }
                        
                        // Green sensitivity peaks at mid wavelengths
                        if (wavelength >= 490 && wavelength <= 580) {
                            reflectance += g * (1 - Math.abs((wavelength - 535) / 45));
                        }
                        
                        // Blue sensitivity peaks at shorter wavelengths
                        if (wavelength <= 490) {
                            reflectance += b * Math.min(1, (490 - wavelength) / 90 + 0.5);
                        }
                        
                        return Math.min(1, Math.max(0.05, reflectance));
                    });
                }

                // Calculate color difference using Kubelka-Munk color similarity
                function calculateColorDifference(reflectance1, reflectance2) {
                    if (!km) return 1000; // Large value if KM not initialized
                    
                    const lab1 = km.reflectanceToCIELAB(reflectance1);
                    const lab2 = km.reflectanceToCIELAB(reflectance2);
                    
                    return km.colorDifference(lab1, lab2);
                }

                // Initialize paint selection UI
                function initializePaintSelection() {
                    availablePaintsContainer.innerHTML = '';
                    
                    // Group paints by series for better organization
                    const paintsBySeries = {};
                    paints.forEach(paint => {
                        const series = paint.series;
                        if (!paintsBySeries[series]) {
                            paintsBySeries[series] = [];
                        }
                        paintsBySeries[series].push(paint);
                    });
                    
                    // Create a sorted array of series
                    const seriesList = Object.keys(paintsBySeries).sort((a, b) => {
                        // Convert to numbers if possible for proper sorting
                        const numA = parseInt(a);
                        const numB = parseInt(b);
                        if (!isNaN(numA) && !isNaN(numB)) return numA - numB;
                        return a.localeCompare(b);
                    });
                    
                    // Create the paint selector UI grouped by series
                    seriesList.forEach(series => {
                        const seriesContainer = document.createElement('div');
                        seriesContainer.className = 'mb-2';
                        
                        // Add series header
                        const seriesHeader = document.createElement('div');
                        seriesHeader.className = 'text-xs font-semibold text-gray-600 mb-1 px-1';
                        seriesHeader.textContent = `Series ${series}`;
                        seriesContainer.appendChild(seriesHeader);
                        
                        // Add paints for this series
                        paintsBySeries[series].forEach(paint => {
                            const paintItem = document.createElement('div');
                            paintItem.className = 'flex items-center p-1 hover:bg-gray-50 paint-item';
                            paintItem.setAttribute('data-paint-id', paint.id);
                            paintItem.setAttribute('data-paint-name', paint.color_name.toLowerCase());
                            
                            const isChecked = selectedPaintIds.includes(paint.id);
                            
                            paintItem.innerHTML = `
                                <input type="checkbox" id="paint-${paint.id}" 
                                    class="paint-checkbox mr-2" ${isChecked ? 'checked' : ''}>
                                <div class="w-4 h-4 rounded-full mr-2" style="background-color: ${paint.rgb_hex}"></div>
                                <label for="paint-${paint.id}" class="text-sm flex-1 cursor-pointer">
                                    ${paint.color_name}
                                    <span class="text-xs text-gray-500 block">
                                        ${paint.pigments.length > 0 ? paint.pigments.join(', ') : 'No pigment data'}
                                    </span>
                                </label>
                            `;
                            
                            // Add event listener to checkbox
                            const checkbox = paintItem.querySelector(`#paint-${paint.id}`);
                            checkbox.addEventListener('change', function() {
                                if (this.checked) {
                                    // Add to selected paints
                                    if (!selectedPaintIds.includes(paint.id)) {
                                        selectedPaintIds.push(paint.id);
                                    }
                                } else {
                                    // Remove from selected paints
                                    const index = selectedPaintIds.indexOf(paint.id);
                                    if (index !== -1) {
                                        selectedPaintIds.splice(index, 1);
                                    }
                                }
                                
                                // Update selected count
                                selectedPaintsCountEl.textContent = selectedPaintIds.length;
                            });
                            
                            seriesContainer.appendChild(paintItem);
                        });
                        
                        availablePaintsContainer.appendChild(seriesContainer);
                    });
                }

                // Handle paint filter input
                paintFilterInput.addEventListener('input', function() {
                    const filterText = this.value.toLowerCase();
                    const paintItems = availablePaintsContainer.querySelectorAll('.paint-item');
                    
                    // Show/hide paint items based on filter
                    paintItems.forEach(item => {
                        const paintName = item.getAttribute('data-paint-name');
                        if (paintName.includes(filterText)) {
                            item.style.display = '';
                        } else {
                            item.style.display = 'none';
                        }
                    });
                });
                
                // Handle select all button
                selectAllPaintsBtn.addEventListener('click', function() {
                    const checkboxes = availablePaintsContainer.querySelectorAll('.paint-checkbox');
                    checkboxes.forEach(checkbox => {
                        checkbox.checked = true;
                    });
                    
                    // Update selected paint IDs
                    selectedPaintIds = paints.map(p => p.id);
                    selectedPaintsCountEl.textContent = selectedPaintIds.length;
                });
                
                // Handle clear all button
                clearAllPaintsBtn.addEventListener('click', function() {
                    const checkboxes = availablePaintsContainer.querySelectorAll('.paint-checkbox');
                    checkboxes.forEach(checkbox => {
                        checkbox.checked = false;
                    });
                    
                    // Clear selected paint IDs
                    selectedPaintIds = [];
                    selectedPaintsCountEl.textContent = '0';
                });
                
                // Initialize paint selection UI
                initializePaintSelection();

                // Find top paint combinations with selected paints only
                function findBestTwoPaintCombinations() {
                    if (!km || selectedPaintIds.length < 2) {
                        return []; // Need at least 2 paints to make combinations
                    }
                    
                    const targetReflectance = rgbToReflectance(targetHexInput.value);
                    const combinations = [];
                    
                    // Filter paints to only include selected ones
                    const selectedPaints = paints.filter(p => selectedPaintIds.includes(p.id));
                    
                    // Try all 2-paint combinations of selected paints
                    for (let i = 0; i < selectedPaints.length; i++) {
                        for (let j = i + 1; j < selectedPaints.length; j++) {
                            // Simple optimization with a few concentration ratios
                            const ratios = [0.1, 0.25, 0.5, 0.75, 0.9];
                            let bestDifference = Infinity;
                            let bestRatio = 0.5;
                            
                            for (const ratio of ratios) {
                                const components = [
                                    { reflectance: selectedPaints[i].reflectance, concentration: ratio },
                                    { reflectance: selectedPaints[j].reflectance, concentration: 1 - ratio }
                                ];
                                
                                const mixedReflectance = km.mixReflectance(components);
                                const difference = calculateColorDifference(targetReflectance, mixedReflectance);
                                
                                if (difference < bestDifference) {
                                    bestDifference = difference;
                                    bestRatio = ratio;
                                }
                            }
                            
                            // Store the result
                            combinations.push({
                                paints: [
                                    { ...selectedPaints[i], concentration: bestRatio },
                                    { ...selectedPaints[j], concentration: 1 - bestRatio }
                                ],
                                difference: bestDifference,
                                // Calculate the mixed color for display
                                resultColor: km.rgbToHex(km.reflectanceToRGB(km.mixReflectance([
                                    { reflectance: selectedPaints[i].reflectance, concentration: bestRatio },
                                    { reflectance: selectedPaints[j].reflectance, concentration: 1 - bestRatio }
                                ])))
                            });
                        }
                    }
                    
                    // Sort by color difference (lower is better)
                    return combinations.sort((a, b) => a.difference - b.difference).slice(0, 5);
                }

                // Find matching paint combinations
                function findMatches() {
                    // Show loading, hide other states
                    matchLoading.classList.remove('hidden');
                    noMatches.classList.add('hidden');
                    matchesContainer.innerHTML = '';
                    
                    // Check if we have enough selected paints
                    if (selectedPaintIds.length < 2) {
                        matchLoading.classList.add('hidden');
                        matchesContainer.innerHTML = '<p class="text-amber-600 p-4">Please select at least 2 paints to find matches.</p>';
                        return;
                    }
                    
                    // Use setTimeout to prevent UI from freezing
                    setTimeout(() => {
                        try {
                            const results = findBestTwoPaintCombinations();
                            renderMatchResults(results);
                        } catch (err) {
                            console.error('Error finding paint matches:', err);
                            matchesContainer.innerHTML = '<p class="text-red-500">Error finding matches. Please try again.</p>';
                        } finally {
                            matchLoading.classList.add('hidden');
                        }
                    }, 100);
                }

                // Render match results
                function renderMatchResults(results) {
                    if (!results || results.length === 0) {
                        noMatches.classList.remove('hidden');
                        return;
                    }
                    
                    matchesContainer.innerHTML = '';
                    
                    results.forEach((result, index) => {
                        const matchElement = document.createElement('div');
                        matchElement.className = 'match-result';
                        
                        // Create header with target and result color
                        const header = document.createElement('div');
                        header.className = 'flex items-center mb-3';
                        header.innerHTML = `
                            <div class="flex-1 font-medium">Match #${index + 1}</div>
                            <div class="flex items-center">
                                <div style="background-color: ${targetHexInput.value}" class="w-6 h-6 rounded-full mr-1 border"></div>
                                <div class="text-gray-500 mx-1">➔</div>
                                <div style="background-color: ${result.resultColor}" class="w-6 h-6 rounded-full border"></div>
                            </div>
                            <div class="ml-3 text-sm text-gray-600">Difference: ${result.difference.toFixed(2)}</div>
                        `;
                        matchElement.appendChild(header);
                        
                        // Create paints list
                        const paintsList = document.createElement('div');
                        paintsList.className = 'space-y-2';
                        
                        result.paints.forEach(paint => {
                            const paintItem = document.createElement('div');
                            paintItem.className = 'flex items-center';
                            paintItem.innerHTML = `
                                <div style="background-color: ${paint.rgb_hex}" class="w-8 h-8 rounded-full mr-2 border"></div>
                                <div class="flex-1">
                                    <div class="font-medium">${paint.color_name}</div>
                                    <div class="text-xs text-gray-600">
                                        Series ${paint.series} • ${paint.pigments.join(', ')}
                                    </div>
                                </div>
                                <div class="text-sm font-semibold">${Math.round(paint.concentration * 100)}%</div>
                            `;
                            
                            // Add a button to use this in mixer
                            const useButton = document.createElement('button');
                            useButton.className = 'ml-2 px-2 py-1 bg-blue-100 text-blue-800 rounded text-xs';
                            useButton.textContent = 'Use in Mixer';
                            useButton.addEventListener('click', function() {
                                // Switch to the mixer tab
                                document.querySelector('.tab[data-tab="mixer"]').click();
                                
                                // Store the paints to be added in the mixer
                                localStorage.setItem('mixerPaints', JSON.stringify(result.paints));
                                
                                // The mixer tab will need to check for this localStorage item on activation
                            });
                            
                            paintItem.appendChild(useButton);
                            paintsList.appendChild(paintItem);
                        });
                        
                        matchElement.appendChild(paintsList);
                        
                        // Add to container
                        matchesContainer.appendChild(matchElement);
                    });
                    
                    // Add a note about mixing
                    const note = document.createElement('div');
                    note.className = 'mt-4 p-3 bg-blue-50 text-sm text-blue-800 rounded';
                    note.innerHTML = `
                        <p>Mix the paints in the proportions shown. The percentages represent the relative amount of each paint to use.</p>
                        <p class="mt-1">For more precise mixing, you can add these paints to the Paint Mixer tab and adjust the concentrations.</p>
                    `;
                    matchesContainer.appendChild(note);
                }
            }
        });
    </script>
</body>
</html>